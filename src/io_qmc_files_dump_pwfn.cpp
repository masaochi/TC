// [namespace io_qmc_files]
// Read/write parameters.casl, write pwfn.data, write jastrow.plt

#include "include/header.hpp"

// called in SCF calculation
void io_qmc_files::dump_pwfn(const FileNames &file_names,
                             const CrystalStructure &crystal_structure,
                             const Kpoints &kpoints,
                             const PlaneWaveBasis &plane_wave_basis,
                             const BlochStates &bloch_states, 
                             const TotalEnergy &total_energy,
                             std::ostream *ost)
{
    const std::string &tc_pwfn = file_names.tc_pwfn();

    const int num_independent_spins = bloch_states.phik_scf().size();
    const int num_irreducible_kpoints = kpoints.num_irreducible_kpoints_scf();
    const double num_electrons = bloch_states.num_electrons();
    const int num_electrons_int = std::round(num_electrons);
    if (std::abs(num_electrons - num_electrons_int) > 1e-5) { error_messages::stop("Non-integer num. of electrons is not allowed."); }
    const int num_atoms = crystal_structure.num_atoms();

    // setup
    *ost << " Dump pwfn.data for CASINO (" << tc_pwfn << ")" << std::endl;
    std::ofstream ofs(tc_pwfn, std::ios::out);
    ofs.fixed;
    ofs.precision(15);
    ofs.showpoint;
    if (ofs.fail()) { error_messages::cannot_open(tc_pwfn); }

    // header
    ofs << std::endl;
    ofs << std::endl;
    ofs << " BASIC INFO" << std::endl;
    ofs << " ----------" << std::endl;
    ofs << " Generated by:" << std::endl;
    ofs << "  TC++" << std::endl;
    ofs << " Method:" << std::endl;
    ofs << "  unknown" << std::endl;
    ofs << " DFT Functional:" << std::endl;
    ofs << "  unknown" << std::endl;
    ofs << " Pseudopotential" << std::endl;
    ofs << "  unknown" << std::endl;
    ofs << " Plane wave cutoff (au)" << std::endl;
    ofs << "  0.0" << std::endl;
    ofs << " Spin polarized" << std::endl;
    if (num_independent_spins==1)
    {
        ofs << " F" << std::endl;
    }
    else if (num_independent_spins==2)
    {
        ofs << " T" << std::endl;
    }
    ofs << " Total energy (au per primitive cell; includes -TS term)" << std::endl;
    ofs << "   0.0" << std::endl;
    ofs << " Kinetic energy (au per primitive cell)" << std::endl;
    ofs << "   0.0" << std::endl;
    ofs << " Local potential energy (au per primitive cell)" << std::endl;
    ofs << "   0.0" << std::endl;
    ofs << " Non local potential energy(au per primitive cell)" << std::endl;
    ofs << "   0.0" << std::endl;
    ofs << " Electron electron energy (au per primitive cell)" << std::endl;
    ofs << "   0.0" << std::endl;
    ofs << " Ion-ion energy (au per primitive cell)" << std::endl;
    ofs << "   " << total_energy.ewald_energy() << std::endl;
    ofs << " Number of electrons per primitive cell" << std::endl;
    ofs << "   " << num_electrons_int << std::endl;
    ofs << std::endl;

    // geometry
    ofs << " GEOMETRY" << std::endl;
    ofs << " --------" << std::endl;
    ofs << " Number of atoms per primitive cell" << std::endl;
    ofs << "   " << num_atoms << std::endl;
    ofs << " Atomic number and position of the atoms(au)" << std::endl;
    for (int iatom=0; iatom<num_atoms; iatom++)
    {
        int iatomic_species = crystal_structure.index_of_atoms()[iatom];
        Eigen::Vector3d position = crystal_structure.atomic_position_cartesian()[iatom];
        ofs << "   " <<  crystal_structure.atomic_number()[iatomic_species] << " " 
            << position[0] << " " << position[1] << " " << position[2] << std::endl;
    }
    ofs << " Primitive lattice vectors (au)" << std::endl;
    for (int idim=0; idim<3; idim++)
    {
        ofs << "   ";
        for (int jdim=0; jdim<3; jdim++) { ofs << crystal_structure.lattice_vectors()(idim, jdim) << "   " ; }
        ofs << std::endl;
    }
    ofs << std::endl;

    // G vectors
    ofs << " G VECTORS" << std::endl;
    ofs << " ---------" << std::endl;
    ofs << " Number of G-vectors" << std::endl;

    // make a full-list of G vectors
    std::vector<bool> full_list_Gindex(plane_wave_basis.size_FFT_grid(), false); // initialized with false
    for (int ispin=0; ispin<num_independent_spins; ispin++)
    {
        for (int ik=0; ik<num_irreducible_kpoints; ik++)
        {
            const int num_G_at_k =  plane_wave_basis.num_G_at_k_scf()[ik];
            for (int isym=0; isym<kpoints.kvectors_scf()[ik].size(); isym++)
            {
                for (int ipw_at_k=0; ipw_at_k<num_G_at_k; ipw_at_k++)
                {
                    int Gindex = plane_wave_basis.Gindex_at_k_scf()[ispin][ik][isym](ipw_at_k);
                    if (!full_list_Gindex[Gindex]) { full_list_Gindex[Gindex] = true; } // included then true
                }
            } // isym
        } // ik
    } // ispin
    const int count_Gindex = std::count(full_list_Gindex.begin(), full_list_Gindex.end(), true);
    ofs << "   " << count_Gindex << std::endl;
    ofs << " Gx Gy Gz (au)" << std::endl;
    for (int ipw=0; ipw<plane_wave_basis.size_FFT_grid(); ipw++)
    {
        if (full_list_Gindex[ipw])
        {
            Eigen::Vector3d Gvect = crystal_structure.reciprocal_vectors().transpose()
                * plane_wave_basis.get_Gvector(ipw).cast<double>();
            ofs << "   " << Gvect(0) << "   " << Gvect(1) << "   " << Gvect(2) << std::endl;
        }
    }
    ofs << std::endl;

    // wave function
    ofs << " WAVE FUNCTION" << std::endl;
    ofs << "  -------------" << std::endl;
    ofs << " Number of k-points" << std::endl;
    ofs << "   " << kpoints.num_kpoints() << std::endl;

    std::vector<int> num_bands(2); // num_bands[ispin]
    if (num_independent_spins==1)
    {
        num_bands[0] = bloch_states.num_bands_scf()[0];
        num_bands[1] = 0; // no down-spin states
    }
    else if (num_independent_spins==2)
    {
        num_bands = bloch_states.num_bands_scf();
    }

    Eigen::VectorXcd phi(plane_wave_basis.size_FFT_grid());
    int ik_tot = 1; // starts from 1
    for (int ik=0; ik<num_irreducible_kpoints; ik++)
    {
        const int num_G_at_k =  plane_wave_basis.num_G_at_k_scf()[ik];
        for (int isym=0; isym<kpoints.kvectors_scf()[ik].size(); isym++)
        {
            const Eigen::Vector3d kvect = crystal_structure.reciprocal_vectors().transpose()
                * kpoints.kvectors_scf()[ik][isym];

            ofs << " k-point # ; # of bands (up spin/down spin);            k-point coords (au)" << std::endl;
            ofs << "   " << ik_tot 
                << "   " << num_bands[0] << "   " << num_bands[1] 
                << "   " << kvect[0] << "   " << kvect[1] << "   " << kvect[2] << std::endl;

            for (int ispin=0; ispin<num_independent_spins; ispin++)
            {
                for (int iband=0; iband<num_bands[ispin]; iband++)
                {
                    ofs << " Band, spin, eigenvalue (au)" << std::endl;
                    ofs << "   " << iband+1 << "   " << ispin+1 
                        << "   " << bloch_states.eigenvalues_scf()[ispin][ik][iband].real() << std::endl; // ignores an imaaginary part!
                    ofs << " Eigenvectors coefficients" << std::endl;

                    plane_wave_basis.get_orbital_FFTgrid(ispin, ik, isym,
                                                         kpoints.is_time_reversal_used_at_k()[ik][isym],
                                                         bloch_states.phik_scf()[ispin][ik][iband][0],
                                                         phi, "SCF");
                    for (int ipw=0; ipw<plane_wave_basis.size_FFT_grid(); ipw++)
                    {
                        if (full_list_Gindex[ipw])
                        {
                            ofs << " " << phi[ipw] << std::endl;
                        }
                    }
                } // iband
            } // ispin
            ik_tot++;
        } // isym
    } // ik
    ofs.close();
}

